## 1. Что происходит, когда пользователь вводит URL в браузер?

Когда пользователь вводит URL (например, `https://example.com`) и нажимает Enter, браузер выполняет следующую последовательность действий:

1. **Парсинг URL** — извлекаются протокол (`https`), домен (`example.com`), порт (по умолчанию 443 для HTTPS), путь и параметры запроса.
2. **Проверка кэша DNS** — браузер ищет IP-адрес домена в локальном кэше (браузера, ОС, роутера).
3. **DNS-запрос** — если IP не найден, браузер отправляет запрос DNS-серверу для разрешения доменного имени в IP-адрес.
4. **Установка TCP-соединения** — выполняется трёхэтапное TCP-рукопожатие (`SYN → SYN-ACK → ACK`) с сервером по полученному IP и порту.
5. **(Для HTTPS) TLS-рукопожатие** — устанавливается защищённое соединение с шифрованием.
6. **Отправка HTTP-запроса** — браузер отправляет HTTP-запрос, например:
   ```http
   GET / HTTP/1.1
   Host: example.com
   ```
7. **Получение HTTP-ответа** — сервер возвращает HTML-документ, заголовки и, возможно, другие ресурсы.
8. **Парсинг и рендеринг** — браузер:
   - Строит DOM из HTML
   - Строит CSSOM из CSS
   - Объединяет их в Render Tree
   - Выполняет JavaScript
   - Загружает дополнительные ресурсы (картинки, скрипты, шрифты)
9. **Отображение страницы** — пользователь видит визуально отрисованную веб-страницу.

Этот процесс может включать кэширование, предзагрузку (prefetch), Service Workers и другие оптимизации.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 2. Что такое Same Origin Policy и почему она важна?

**Same Origin Policy (SOP)** — это механизм безопасности, встроенный в браузеры, который **запрещает скриптам с одного источника (origin) взаимодействовать с ресурсами другого источника** без явного разрешения.

**Источник определяется** по трём компонентам:

- **Протокол** (`http` или `https`)
- **Домен** (`example.com`)
- **Порт** (`80`, `443`, `3000` и т.д.)

Примеры:

- `https://api.example.com` ≠ `https://example.com` → разные источники.
- `http://example.com` ≠ `https://example.com` → разные источники.

**Зачем нужна SOP?**

- Предотвращает **кражу данных** (например, атаки CSRF, XSS).
- Гарантирует, что вредоносный сайт не сможет прочитать содержимое сессии на `bank.com`, даже если пользователь в ней авторизован.
- Защищает конфиденциальные данные (cookies, localStorage).

> ❗ SOP **не блокирует отправку запроса**, но **блокирует чтение ответа**, если источник не совпадает.

---

## 3. Что такое CORS и зачем он нужен?

**CORS (Cross-Origin Resource Sharing)** — это механизм, позволяющий **безопасно выполнять междоменные запросы**, обходя ограничения Same Origin Policy.

**Как работает**:

- Браузер автоматически добавляет заголовок `Origin` к междоменным запросам.
- Сервер отвечает заголовком `Access-Control-Allow-Origin`, например:

  ```http
  Access-Control-Allow-Origin: https://trusted-frontend.com
  ```

  или

  ```http
  Access-Control-Allow-Origin: *
  ```

**Зачем нужен CORS?**

- Позволяет легитимным фронтендам (например, `app.example.com`) обращаться к API (`api.example.com`).
- Сервер **сам решает**, каким доменам разрешить доступ.
- Обеспечивает безопасность: без CORS любой сайт мог бы читать ваши данные с любого API.

> ⚠️ CORS проверяется **только браузером**. Инструменты вроде `curl` или Postman игнорируют CORS.

---

## 4. Что такое preflight-запрос и когда он выполняется?

**Preflight-запрос** — это автоматический `OPTIONS`-запрос, который браузер отправляет **перед основным междоменным запросом**, чтобы убедиться, что он разрешён сервером.

**Preflight выполняется, если запрос «непростой»**, то есть:

- Метод не `GET`, `POST` или `HEAD`
- Используются **кастомные заголовки** (`Authorization`, `X-Requested-With`)
- `Content-Type` — не один из «безопасных»:
  - `application/x-www-form-urlencoded`
  - `multipart/form-data`
  - `text/plain`

**Пример вызова preflight**:

```js
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json'
  }
});
```

**Сервер должен ответить на `OPTIONS`**:

```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: PUT, POST, GET
Access-Control-Allow-Headers: Content-Type
Access-Control-Max-Age: 86400
```

Если preflight успешен — браузер отправляет основной запрос.

---

## 5. Что такое cookies и как они работают при запросах?

**Cookies** — это небольшие фрагменты данных, которые сервер отправляет браузеру через заголовок `Set-Cookie`. Браузер сохраняет их и **автоматически включает в последующие запросы** к тому же источнику.

**Пример**:

```http
Set-Cookie: sessionId=abc123; Path=/; Domain=.example.com; Secure; HttpOnly; SameSite=Lax
```

**Основные атрибуты**:

- `Secure` — отправлять только по HTTPS
- `HttpOnly` — недоступны из JavaScript (защита от XSS)
- `SameSite=Strict/Lax` — предотвращает отправку при межсайтовых запросах (защита от CSRF)
- `Path`, `Domain` — определяют область действия

**При запросах**:

- Браузер автоматически добавляет: `Cookie: sessionId=abc123`
- При CORS-запросах cookies **не отправляются по умолчанию** — нужно:

  ```js
  fetch(url, { credentials: 'include' });
  ```

  И сервер должен ответить:

  ```http
  Access-Control-Allow-Credentials: true
  ```

---

## 6. Чем отличаются DOM, CSSOM и Render Tree?

| Структура                    | Описание                                                                                   | Формируется из                                          |
| ------------------------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **DOM** (Document Object Model) | Дерево узлов, представляющее HTML-документ                        | Парсинг HTML                                                  |
| **CSSOM** (CSS Object Model)    | Дерево стилей, применяемых к элементам                            | Парсинг CSS                                                   |
| **Render Tree**                 | Дерево**видимых** элементов с вычисленными стилями | DOM + CSSOM (без `display: none`, `<head>`, скриптов) |

**Процесс рендеринга**:

1. HTML → DOM
2. CSS → CSSOM
3. DOM + CSSOM → Render Tree
4. Render Tree → Layout (вычисление геометрии: позиции, размеры)
5. Layout → Paint (отрисовка пикселей на экране)

JavaScript может модифицировать DOM/CSSOM → вызывает перестройку Render Tree → рефлоу (layout) и репейнт (paint).

---

## 7. Что такое AJAX и какие данные можно передавать через XHR / fetch?

**AJAX (Asynchronous JavaScript and XML)** — подход к обмену данными с сервером **без перезагрузки страницы**, с асинхронным обновлением части интерфейса.

**Инструменты**:

- `XMLHttpRequest` (XHR) — старый, callback-ориентированный API
- `fetch()` — современный, основанный на Promise

**Типы данных, которые можно передавать**:

- **Текст** (`text/plain`)
- **JSON** (`application/json`) — самый популярный формат
- **HTML** (`text/html`)
- **XML** (`application/xml`) — исторически, редко
- **Формы** (`application/x-www-form-urlencoded`, `multipart/form-data`)
- **Бинарные данные** через `FormData`, `Blob`, `ArrayBuffer`

**Пример**:

```js
fetch('/api/user', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'Иван' })
});
```

> ❗ Все запросы из браузера подчиняются CORS и SOP.

---

## 8. Что такое MIME-типы и зачем они нужны?

**MIME-тип (Media Type)** — строка, описывающая **тип и формат содержимого**. Используется в HTTP-заголовках.

**Формат**: `type/subtype`Примеры:

- `text/html`
- `application/json`
- `image/png`
- `application/javascript`

**Где используются**:

- Заголовок `Content-Type` в **ответе** — говорит браузеру, как интерпретировать тело.
- Заголовок `Accept` в **запросе** — говорит серверу, какие типы клиент понимает.

**Зачем нужны**:

- Чтобы браузер знал: исполнять как JS, отображать как изображение или показывать как текст.
- Без правильного MIME-типа:
  - JS не выполнится
  - JSON покажется как сырой текст
  - SVG не отрендерится

> Некоторые браузеры делают «MIME sniffing», но это небезопасно → сервер должен явно указывать тип.

---

## 9. Что такое JSON и почему он стал стандартом обмена данными?

**JSON (JavaScript Object Notation)** — это **лёгкий текстовый формат** для представления структурированных данных.

**Синтаксис**:

```json
{
  "name": "Иван",
  "age": 25,
  "isStudent": false,
  "courses": ["Математика", "Программирование"]
}
```

**Поддерживаемые типы**:

- Строки, числа, булевы, `null`
- Массивы (`[]`)
- Объекты (`{}`)

**Не поддерживает**:

- Функции
- Даты (передаются как строки)
- Комментарии

**Почему стал стандартом**:

1. **Простота** — легко читать и писать
2. **Языконезависимость** — библиотеки для всех языков
3. **Нативная поддержка в JavaScript** — `JSON.parse()`, `JSON.stringify()`
4. **Минималистичность** — меньше оверхеда, чем у XML
5. **Интеграция с REST API** — де-факто стандарт для веб-API

---

## 10. Что такое TCP-рукопожатие и как устанавливается соединение?

**TCP-рукопожатие (Three-way handshake)** — это процесс установки надёжного соединения между клиентом и сервером по протоколу TCP.

**Этапы**:

1. **SYN** (Клиент → Сервер)Клиент отправляет пакет с флагом `SYN=1` и случайным номером последовательности: `seq=x`.
2. **SYN-ACK** (Сервер → Клиент)Сервер отвечает пакетом с `SYN=1`, `ACK=1`, подтверждением `ack=x+1` и своим `seq=y`.
3. **ACK** (Клиент → Сервер)
   Клиент отправляет `ACK=1`, `ack=y+1`, подтверждая получение.

После этого соединение считается **установленным**, и начинается передача данных.

**Зачем нужно**:

- Гарантирует, что обе стороны **готовы к обмену**
- Синхронизирует номера последовательностей для надёжной доставки
- Обеспечивает **надёжность**, контроль потока и повторную передачу при потере пакетов

> При закрытии соединения используется **четырёхэтапное завершение** (`FIN`/`ACK`).
