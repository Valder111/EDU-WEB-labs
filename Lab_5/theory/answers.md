# "answer.md"

---

## 1. Call Stack и Event Loop

### Что это такое и как связаны?

- **Call Stack** — это структура данных, которая отслеживает, какие функции выполняются в данный момент. Каждый вызов функции помещается в стек (`push`), а после завершения — удаляется из него (`pop`). JavaScript — однопоточный, поэтому в один момент времени выполняется только одна функция.
- **Event Loop** — это механизм, который обеспечивает выполнение асинхронного кода в однопоточной среде JavaScript. Он постоянно проверяет, пуст ли Call Stack, и если да — перемещает задачи из очередей (macrotasks/microtasks) в Call Stack для выполнения.

**Связь:** Event Loop позволяет JavaScript «не блокироваться» при асинхронных операциях (таймеры, сетевые запросы), а Call Stack — выполнять синхронный код пошагово.

---

### С какими видами задач они работают?

- **Macrotasks** (очередь задач):`setTimeout`, `setInterval`, `setImmediate` (Node.js), `I/O`, `UI rendering`.
- **Microtasks** (очередь микрозадач):
  `Promise.then/catch/finally`, `queueMicrotask`, `MutationObserver`.

> **Важно:** После выполнения каждой macrotask'и Event Loop обрабатывает **все доступные microtasks** перед следующей macrotask'ой.

---

### Пример и порядок выполнения

```js
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');
```

**Порядок вывода:**

```
1
4
3
2
```

**Объяснение:**

1. Синхронный код (`1`, `4`) выполняется сразу.
2. `Promise.then` → microtask → выполняется **до** следующего macrotask.
3. `setTimeout` → macrotask → выполняется **после** всех microtasks.

---

## 2. Promise

### Определение и назначение

**Promise** — это объект, представляющий **результат асинхронной операции**, которая может завершиться успешно (`fulfilled`) или с ошибкой (`rejected`).Нужен для:

- Устранения «callback hell»
- Структурирования асинхронного кода
- Композиции асинхронных операций

---

### Где встречается в JS?

- `fetch()` → возвращает Promise
- `Promise.resolve() / Promise.reject()`
- `async`-функции → всегда возвращают Promise
- Многие современные API: `caches.open()`, `navigator.share()`, etc.

---

### Состояния и работа через `.then()` / `.catch()`

**Состояния:**

- `pending` — начальное состояние
- `fulfilled` — операция завершена успешно
- `rejected` — операция завершена с ошибкой

**Методы:**

```js
promise
  .then(result => { /* успешный результат */ })
  .catch(error => { /* обработка ошибки */ })
  .finally(() => { /* выполняется всегда */ });
```

`.catch()` перехватывает ошибки из `.then()` или из самого промиса.

---

### Статические методы

| Метод                       | Назначение                                                                                                                                                      |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Promise.all(promises)`        | Ждёт**все** промисы. Если **хотя бы один** отклонён — возвращает rejected.                                     |
| `Promise.allSettled(promises)` | Ждёт **все**, независимо от результата. Возвращает массив с `status` и `value/reason`.                          |
| `Promise.race(promises)`       | Возвращает результат**первого завершившегося** промиса (успех или ошибка).                             |
| `Promise.any(promises)`        | Возвращает**первый успешно завершившийся** промис. Если все rejected — выбрасывает `AggregateError`. |

---

## 3. `fetch`

### Что это и зачем нужен?

`fetch()` — это **современный API** для выполнения HTTP-запросов в браузере.
Заменяет устаревший `XMLHttpRequest`.
Возвращает **Promise**, который резолвится в объект `Response`.

---

### Основные `options`

```js
fetch(url, {
  method: 'GET', // или POST, PUT, DELETE и т.д.
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data), // для POST/PUT
  credentials: 'include', // отправлять куки
  cache: 'no-cache',
  mode: 'cors', // cors, no-cors, same-origin
  redirect: 'follow', // manual, error
  signal: AbortSignal.timeout(5000) // отмена через 5 сек
})
```

> `fetch` **не считает HTTP-ошибки (404, 500)** за ошибки JavaScript! Нужно проверять `response.ok`.

---

## 4. Принципы проектирования

### DRY (Don’t Repeat Yourself)

**Суть:** Не дублируйте код — выносите повторяющуюся логику в функции/модули.

**Пример из кода:**

```js
// Плохо — дублирование
fetch(url1).then(r => r.json()).then(...);
fetch(url2).then(r => r.json()).then(...);

// Хорошо — DRY
const getJson = url => fetch(url).then(r => r.json());
```

---

### KISS (Keep It Simple, Stupid)

**Суть:** Простота важнее сложных решений. Избегайте преждевременной оптимизации.

**Пример:**
Вместо создания сложного класса для одного запроса — используем простую функцию:

```js
// KISS-подход
const loadUser = id => fetch(`/api/user/${id}`).then(r => r.json());
```

---

### S.O.L.I.D.

[Почитать](https://habr.com/ru/articles/688530/)

- **S** — Single Responsibility: каждый модуль делает **одно дело**.→ `ajax.js` отвечает **только за запросы**, `urls.js` — только за генерацию URL.
- **O** — Open/Closed: код открыт для расширения, закрыт для изменения.→ Можно добавить новый метод в `urls.js`, не трогая `MainPage.js`.
- **L** — Liskov Substitution: наследники должны заменять родителя без сбоев.→ (менее применимо в функциональном JS, но важно в ООП)
- **I** — Interface Segregation: не заставляйте клиентов зависеть от ненужных методов.→ Компоненты получают только нужные им пропсы.
- **D** — Dependency Inversion: зависьте от абстракций, а не от конкретики.
  → `MainPage` зависит от интерфейса `ajax.post()`, а не от реализации (`fetch` или `XHR`).

---

## 5. Web Storage API

Web Storage API предоставляет **два механизма** хранения данных в браузере:

### 1. `localStorage`

- **Хранение:** **постоянное** (до очистки пользователем или программно)
- **Область видимости:** один и тот же origin (протокол + домен + порт)
- **Доступно после перезагрузки, закрытия браузера**
- **Объём:** ~5–10 МБ (зависит от браузера)

### 2. `sessionStorage`

- **Хранение:** **временное** — только в рамках **одной вкладки/сессии**
- Удаляется при **закрытии вкладки**
- Не передаётся между вкладками (даже одного сайта)

---

### Общие методы (у обоих)

| Метод               | Назначение                                                    |
| ------------------------ | ----------------------------------------------------------------------- |
| `.setItem(key, value)` | Сохраняет строку по ключу                         |
| `.getItem(key)`        | Возвращает значение по ключу (или `null`) |
| `.removeItem(key)`     | Удаляет пару ключ-значение                       |
| `.clear()`             | Очищает всё хранилище                                |
| `.key(index)`          | Возвращает ключ по индексу                       |
| `.length`              | Количество сохранённых элементов          |

> **Важно:** Хранятся **только строки**. Для объектов — используйте `JSON.stringify()` / `JSON.parse()`.

---

### Примеры использования

```js
// Сохранение
localStorage.setItem('theme', 'dark');
sessionStorage.setItem('formDraft', JSON.stringify({ name: 'Иван' }));

// Чтение
const theme = localStorage.getItem('theme'); // 'dark'
const draft = JSON.parse(sessionStorage.getItem('formDraft') || '{}');

// Удаление
localStorage.removeItem('theme');
sessionStorage.clear();
```

### Особенности

| Характеристика                              | `localStorage`                 | `sessionStorage`                                   |
| --------------------------------------------------------- | -------------------------------- | ---------------------------------------------------- |
| Жизненный цикл                               | Пока не удалён       | Пока не закрыта вкладка          |
| Доступ между вкладками                | Да                             | Нет                                               |
| Доступ после перезагрузки          | Да                             | Да (в той же вкладке)                 |
| Доступ после закрытия браузера | Да                             | Нет                                               |
| Используется для                           | Настройки, токены | Временные данные (черновики) |

   **Безопасность:** Никогда нельзя хранить **чувствительные данные** (пароли, токены доступа к API) в `localStorage` — уязвимость к XSS.
